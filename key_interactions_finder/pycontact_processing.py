"""
Reformats and (optionally) merges PyContact datafiles generated using the custom python script.

Special Note:
A pycontact job run with overlapping residue selections can obtain many false interactions.
These false interactions would be for instance a vdw interaction between a residue to itself.
If this is the case, the 'remove_false_interactions' must be set to True (default) when the
class is initialised in order to remove these false interactions.
"""
import re
from typing import Union, Optional
from dataclasses import dataclass, field
import pandas as pd


@dataclass
class PyContactInitializer():
    """Class for converting PyContact output files generated by the Python script."""

    # Generated when instantiated.
    pycontact_files: Union[str, list]
    merge_files_method: Optional[str]
    multiple_files: bool = False
    remove_false_interactions: bool = True
    in_dir: str = ""

    # Generated later.
    individ_dfs: Optional[list] = field(init=False)
    full_df: pd.DataFrame = field(init=False)
    prepared_df: pd.DataFrame = field(init=False)

    # This is called at the end of the dataclass's initialization procedure.
    def __post_init__(self):
        """Processes the provided PyContact files."""
        if self.in_dir[-1] != "/":
            self.in_dir += "/"

        if not self.multiple_files:
            self.full_df = self._load_pycontact_dataset(self.pycontact_files)
        else:
            self.individ_dfs = [
                self._load_pycontact_dataset(i) for i in self.pycontact_files]

            if self.merge_files_method == "vertical":
                self.full_df = self._merge_pycontact_datasets_vertically()
            elif self.merge_files_method == "horizontal":
                self.full_df = self._merge_pycontact_datasets_horizontally()
            else:
                raise ValueError(
                    """You said you had multiple files but you did not define the
                    'merge_files_method' parameter as either 'vertical' or 'horizontal'.""")

        if self.remove_false_interactions:
            self.prepared_df = self._rm_false_interactions()
        else:
            self.prepared_df = self.full_df

        num_feats = len(self.prepared_df.columns)
        num_obs = len(self.prepared_df)
        print("Your PyContact file(s) have been succefully processed.")
        print(f"You have {num_feats} features and {num_obs} observations.")
        print("The fully processed dataframe is accesible from the 'prepared_df' class attribute.")

    def _load_pycontact_dataset(self, input_file):
        """Load a single PyContact dataset."""
        file_in_path = self.in_dir + input_file
        return pd.read_csv(file_in_path)

    def _merge_pycontact_datasets_horizontally(self):
        """
        Function to merge multiple PyContact dfs horizontally

        This would be used when a user has analysed different parts of their protein
        with PyContact and wants to put them all together (i.e. each file is from the
        same trajectory.)

        Returns
        ----------
        pd.DataFrame
            A complete dataframe with the individual dfs merged.
        """
        df_lengths = [len(df) for df in self.individ_dfs]

        if len(set(df_lengths)) != 1:
            except_message = "The number of rows in each of your datasets are not identical. This is weird because you asked " + \
                "to merge your files horizontally. If you are using this approach then your files should be from the " + \
                "same trajectory frames, just with different contacts measured in each of them. " + \
                "If not, you want to set the 'merge_files_method' parameter to 'vertical'. "
            raise Exception(except_message)

        merged_df = pd.concat(self.individ_dfs, axis=1)
        merged_df = merged_df.fillna(0.0)
        return merged_df

    def _merge_pycontact_datasets_vertically(self):
        """
        Function to merge multiple PyContact dfs vertically.
        This would be used when a user has multiple replicas or has broken
        there trajectory into blocks of seperate frames.

        Returns
        ----------
        pd.DataFrame
            A complete dataframe with individual dataframe merged in the same order as they were given.
        """
        merged_df = pd.concat(
            self.individ_dfs, ignore_index='True', sort='False')
        merged_df = merged_df.fillna(0.0)
        return merged_df

    def _interaction_is_duplicate(self, contact_parts, contacts_to_keep):
        """
        Check if current interaction is a duplicate of an already kept contact.
        Duplicates are identical but have the residue order swapped.
        i.e. resX + resY + [other columns] vs. resY + resX + [other columns]

        Parameters
        ----------
        contact_parts: list
            The feature/contact to test whether it is a duplicate of a pre-existing contact.
            The list items are different parts of the contact.

        contacts_to_keep: list
            A list of all current features that will be kept.
            (Used to determine if new feature is duplicate of these.)

        Returns
        ----------
        bool
            True if contact is a duplicate.
        """
        duplicate = False
        for saved_contact in contacts_to_keep:
            if (
                (contact_parts[2] == saved_contact[0]) and
                (contact_parts[0] == saved_contact[2]) and
                (contact_parts[4] == saved_contact[4]) and
                (contact_parts[5] == saved_contact[5])
            ):
                duplicate = True
                break

        return duplicate

    def _rm_false_interactions(self):
        """
        Remove non-meaningful (too close to one another) or duplicate contacts/features.
        Required if in the PyContact job run a user sets the second residue selection.
        group to be something other than "self" and the residue selections overlap.
        Doesn't hurt to be run if not anyway.
        """
        contacts_to_del = []
        contacts_to_keep = []
        column_names = self.full_df.columns
        for idx, contact in enumerate(column_names):
            contact_parts = re.split("(\d+|\s)", contact)
            # remove the list items with empty or single spaces from the above regex.
            for list_index in sorted([0, 3, 4, 7, 9], reverse=True):
                del contact_parts[list_index]

            residue_gap = abs(int(contact_parts[0]) - int(contact_parts[2]))
            # Remove vdw type interactions if <= 3 residues of each other.
            if contact_parts[4] in ["Other", "Hydrophobic"]:
                if residue_gap <= 3:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)
            # Remove Hbond and Saltbr if <= 1 residues of each other.
            else:
                if residue_gap <= 1:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)

            if self._interaction_is_duplicate(contact_parts, contacts_to_keep):
                contacts_to_del.append(idx)

        prepared_df = self.full_df.drop(
            self.full_df.columns[contacts_to_del], axis=1)
        return prepared_df
