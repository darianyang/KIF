"""
Reformats and (optionally) merges PyContact datafiles generated by the custom python script.
TODO - ADD a comment here about importance of using "self" as second parameter and what happends if kept.
"""
import os
import re
from typing import Union
from dataclasses import dataclass, field
import pandas as pd


@dataclass
class PyContactInitializer():
    """Class for converting PyContact output files generated by the Python script."""

    # Generated when instantiated.
    pycontact_files: Union[str, list]
    base_name: str
    multiple_files: bool = False
    remove_false_interactions: bool = False
    in_dir: str = ""

    # Generated later.
    individ_dfs: list = field(init=False)  # I WANT TO MARK AS OPTIONAL? TODO
    full_df: pd.core.frame.DataFrame = field(init=False)
    prepared_df: pd.core.frame.DataFrame = field(init=False)

    # This is called at the end of the dataclass's initialization procedure.
    def __post_init__(self):
        """Processes the provided PyContact files."""
        if self.in_dir[-1] != "/":
            self.in_dir += "/"

        if not self.multiple_files:
            self.full_df = self._load_pycontact_dataset(self.pycontact_files)
        else:
            self.individ_dfs = [
                self._load_pycontact_dataset(i) for i in self.pycontact_files]
            self.full_df = self._merge_pycontact_datasets()

        if self.remove_false_interactions:
            self.prepared_df = self._rm_false_interactions()
        else:
            self.prepared_df = self.full_df

        print("processing complete")  # TODO MAKE THIS AN INFORMATIVE SUMMARY.

    def _load_pycontact_dataset(self, input_file):
        """Load and preps a single PyContact dataset."""
        file_in_path = self.in_dir + input_file
        df = pd.read_csv(file_in_path)
        return df

    def _merge_pycontact_datasets(self):
        """
        Function to merge multiple PyContact dfs.
        dfs merged in the same order as they are given.
        """
        merged_df = pd.concat(
            self.individ_dfs, ignore_index='True', sort='False')
        merged_df = merged_df.fillna(0.0)
        return merged_df

    def _is_duplicate(self, contact_parts, contacts_to_keep):
        """
        Check if current interaction is a duplicate of an already kept contact.
        Duplicates are identical but have the residue order swapped.
        i.e. resX + resY + [other columns] vs. resY + resX + [other columns]
        Returns a boolean.
        """
        duplicate = False
        for saved_contact in contacts_to_keep:
            if (
                (contact_parts[2] == saved_contact[0]) and
                (contact_parts[0] == saved_contact[2]) and
                (contact_parts[4] == saved_contact[4]) and
                (contact_parts[5] == saved_contact[5])
            ):
                duplicate = True
                break  # don't need to continue looping if True.

        return duplicate

    def _rm_false_interactions(self):
        """
        Remove non-meaningful (too close to one another) or duplicate contacts/features...
        Required if in the PyContact job run a user sets the second residue selection...
        group to be something other than "self" but selections residues overlaps.
        """
        contacts_to_del = []
        contacts_to_keep = []
        column_names = self.full_df.columns
        for idx, contact in enumerate(column_names):
            contact_parts = re.split("(\d+|\s)", contact)
            # remove the list items with empty or single spaces from the above regex.
            for list_index in sorted([0, 3, 4, 7, 9], reverse=True):
                del contact_parts[list_index]

            # Remove vdw type interactions if <= 3 residues of each other.
            if contact_parts[4] in ["Other", "Hydrophobic"]:
                residue_gap = abs(
                    int(contact_parts[0]) - int(contact_parts[2]))
                if residue_gap <= 3:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)
            # Remove Hbond and Saltbr only if same residue.
            else:
                if contact_parts[0] == contact_parts[2]:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)

            # Check for duplicates.
            if self._is_duplicate(contact_parts, contacts_to_keep):
                contacts_to_del.append(idx)

        prepared_df = self.full_df.drop(
            self.full_df.columns[contacts_to_del], axis=1)
        return prepared_df


def main():
    """Do Nothing"""
    pass


if __name__ == main:
    main()
