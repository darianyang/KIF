"""
Reformats and (optionally) merges PyContact datafiles generated using the custom python script.
TODO - ADD a comment here about importance of using "self" as second parameter and what happends if kept.
"""
import re
from typing import Union, Optional
from dataclasses import dataclass, field
import pandas as pd


@dataclass
class PyContactInitializer():
    """Class for converting PyContact output files generated by the Python script."""

    # Generated when instantiated.
    pycontact_files: Union[str, list]
    base_name: str
    multiple_files: bool = False
    remove_false_interactions: bool = False
    in_dir: str = ""

    # Generated later.
    individ_dfs: Optional[list] = field(init=False)
    full_df: pd.core.frame.DataFrame = field(init=False)
    prepared_df: pd.core.frame.DataFrame = field(init=False)

    # This is called at the end of the dataclass's initialization procedure.
    def __post_init__(self):
        """Processes the provided PyContact files."""
        if self.in_dir[-1] != "/":
            self.in_dir += "/"

        if not self.multiple_files:
            self.full_df = self._load_pycontact_dataset(self.pycontact_files)
        else:
            self.individ_dfs = [
                self._load_pycontact_dataset(i) for i in self.pycontact_files]
            self.full_df = self._merge_pycontact_datasets()

        if self.remove_false_interactions:
            self.prepared_df = self._rm_false_interactions()
        else:
            self.prepared_df = self.full_df

        print("PyContact file(s) have been succefully processed.")
        print(f"You now have xxxx features and xxxx observations.")  # TODO

    def _load_pycontact_dataset(self, input_file):
        """Load and preps a single PyContact dataset."""
        file_in_path = self.in_dir + input_file
        return pd.read_csv(file_in_path)

    def _merge_pycontact_datasets(self):
        """
        Function to merge multiple PyContact dfs.
        dfs merged in the same order as they are given.
        """
        merged_df = pd.concat(
            self.individ_dfs, ignore_index='True', sort='False')
        merged_df = merged_df.fillna(0.0)
        return merged_df

    def _interaction_is_duplicate(self, contact_parts, contacts_to_keep):
        """
        Check if current interaction is a duplicate of an already kept contact.
        Duplicates are identical but have the residue order swapped.
        i.e. resX + resY + [other columns] vs. resY + resX + [other columns]

        Parameters
        ----------
        contact_parts: list
            The feature/contact to test whether it is a duplicate of a pre-existing contact.
            The list items are different parts of the contact.

        contacts_to_keep: list
            A list of all current features that will be kept.
            (Used to determine if new feature is duplicate of these.)

        Returns
        ----------
        bool
            True if contact is a duplicate.
        """
        duplicate = False
        for saved_contact in contacts_to_keep:
            if (
                (contact_parts[2] == saved_contact[0]) and
                (contact_parts[0] == saved_contact[2]) and
                (contact_parts[4] == saved_contact[4]) and
                (contact_parts[5] == saved_contact[5])
            ):
                duplicate = True
                break  # don't need to continue looping if True.

        return duplicate

    def _rm_false_interactions(self):
        """
        Remove non-meaningful (too close to one another) or duplicate contacts/features.
        Required if in the PyContact job run a user sets the second residue selection.
        group to be something other than "self" and the residue selections overlap.
        Doesn't hurt to be run if not anyway.
        """
        contacts_to_del = []
        contacts_to_keep = []
        column_names = self.full_df.columns
        for idx, contact in enumerate(column_names):
            contact_parts = re.split("(\d+|\s)", contact)
            # remove the list items with empty or single spaces from the above regex.
            for list_index in sorted([0, 3, 4, 7, 9], reverse=True):
                del contact_parts[list_index]

            residue_gap = abs(int(contact_parts[0]) - int(contact_parts[2]))
            # Remove vdw type interactions if <= 3 residues of each other.
            if contact_parts[4] in ["Other", "Hydrophobic"]:
                if residue_gap <= 3:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)
            # Remove Hbond and Saltbr if <= 1 residues of each other.
            else:
                if residue_gap <= 1:
                    contacts_to_del.append(idx)
                else:
                    contacts_to_keep.append(contact_parts)

            if self._interaction_is_duplicate(contact_parts, contacts_to_keep):
                contacts_to_del.append(idx)

        prepared_df = self.full_df.drop(
            self.full_df.columns[contacts_to_del], axis=1)
        return prepared_df


def main():
    """Do Nothing"""


if __name__ == "__main__":
    main()
